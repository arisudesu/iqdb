#!/usr/bin/perl

use warnings;
use strict;

use DBI;
use URI::Escape;
use File::Find;
use Compress::Zlib;

# danbooru-change [-l] tag [-r] [-w<num>] mode [max]
# tag=site mode=update/full/deleted/fromdb -l no lock -r no online update

my $nolock = shift, 1 if @ARGV and $ARGV[0] eq '-l';
die "No lockfile!\n" unless $nolock or -e "update.lock";

#system("renice 15 $$");
my $tag = shift or die "Give server tag on command line.\n";
my $no_online = shift, 1 if @ARGV and $ARGV[0] eq '-r';
my $warnmax = 4;
$warnmax = 0+$1 if @ARGV and $ARGV[0] =~ /-w(\d+)/ and shift;
my $mode = "update";
$mode = shift if @ARGV and ($ARGV[0] =~ /^[a-z]+$/);
my $max = 0+(shift||0);
my $cnt = 0;
my $start_time = time;
print "Getting no more than $max posts.\n" if $max > 0;

our ($user,$pw,$host,$table,$dbid,$db_file,%url,$def_rating);
do "/usr/src/packages/sim/$tag.cfg" and (defined $user and defined $pw or %url) and $host and $table and $dbid and $db_file or die "$tag: Can't get DB settings: $!\n";
$db_file="/opt/stuff/$db_file";
die "$tag: $db_file does not exist\n" unless -e $db_file;
chdir "$ENV{HOME}/doujin/$tag" or die "$tag: Can't chdir: $!\n";

print "Site: $tag Mode: $mode\n";

my $last_change = get_last('change');
my $last_post = get_last('id');
my $last_max = eval { get_last('max') };
$max = $last_max if $last_max;

my $pwfile = "$ENV{HOME}/.dou-pw-admin";
open my $f, "<", $pwfile or die "$tag: Can't read $pwfile: $!\n";
my $password = <$f>;
chomp $password;
die "$tag: No password in $pwfile\n" unless $password;

$|=1;
open $f, ">", ".curmode" or die "$tag: Can't write .curmode: $!\n";
print $f $mode;
close $f;

my %ids_db;
my %ids_online;
my %md5;

sub failed {
	my $failed = get_failed();
	put_failed($failed + 1);
	print STDERR "$tag: Failed $failed times before.\n", @_ if $failed;
	# only die for second message, again after 4 hours and then every ~24 hours
	print STDERR @_ and exit unless $failed == 1 or $failed == 8 or $failed == 24 or ($failed & 127) == 127;
	die @_;
};

if ($mode eq 'fromdb') {
	print "Finding images... ";
	find({ wanted => sub { return unless -f and m#^([0-9a-f]{32})\.#; $md5{$1} = 1; } }, "0".."9", "a".."f");
	print scalar keys %md5, " found.\n";
	get_ids();
}

my $dbh = DBI->connect("DBI:mysql:database=sim:host=localhost", "simadmin", $password)
	or die "$tag: Can't connect to database: $DBI::errstr\n";

$dbh->do(<<EOT) or die "$tag: FAILED.\n";
	create table if not exists $table (
		id int not null,
		rating char(1) character set latin1,
		md5 binary(32) not null,
		post blob not null,

		UNIQUE INDEX(id),
		PRIMARY KEY(id),
		UNIQUE INDEX(md5)
	) CHARSET=utf8 INDEX DIRECTORY='/var/lib/mysql-index/sim' DATA DIRECTORY='/var/lib/mysql-data/sim';
EOT

my $ua = MyUserAgent->new;
$ua->timeout(10);
$ua->env_proxy;
$ua->agent("iqdb/0.1 (+http://iqdb.org/)");

use LWP::ConnCache;
$ua->conn_cache(LWP::ConnCache->new(5));

my @remove;
my @add;
my @insert;
my @update;

my @tofetch;

my %deleted;

my $sth_chk = $dbh->prepare("select rating from $table where id=?") or exit 1;
my $sth_ins = $dbh->prepare("insert into $table (id, rating, md5, post) values (?, ?, ?, ?) on duplicate key update id=values(id),rating=values(rating),post=values(post)") or exit 1;

my %ratings = (a => 0x02, e => 0x04, q => 0x08, s => 0x10);

my $warn = 0;
my $err = 0;
my $last_del = 0;

my $sth;
if ($mode eq 'fromdb') {
	$sth = $dbh->prepare("select * from $table") or exit 1;
	$sth->execute();
}

AGAIN:
while(!$max or $cnt < $max) {
	my $query;
	my $posts;
	if ($mode eq 'full') {
		$query = "change:>$last_change order:change";
	} elsif ($mode eq 'deleted') {
		die "This should probably use status:deleted now.\n";
		$query = "id:>$last_del order:id deleted:true";
	} elsif ($mode eq 'update') {
		$query = "id:>$last_post order:id";
	} elsif ($mode eq 'fromdb') {
		if (@tofetch) {
			my $md5 = shift @tofetch;
			print "Trying to get MD5 $md5...\n";
			$query = "md5:$md5";
		} else {
			last unless $sth;
			my $row = $sth->fetchrow_hashref or last;
			$posts = MyUserAgent::parse(Compress::Zlib::uncompress($row->{post}));
			$_->{noinsert} = 1 for @$posts;
		}
	} else {
		die "$tag: Unknown mode: $mode\n";
	}
	my $req_url;
	if (%url) {
		my %values = (ID => $last_post, CHANGE => $last_change);
		failed "$tag: mode '$mode' has no URL\n" unless exists $url{$mode};
		$req_url = $url{$mode};
		$req_url =~ s/<([A-Z]+)>/exists $values{$1} or die "$1\n"; $values{$1}/eg;
	} else {
		my $login = $user ? "&login=$user&password_hash=$pw" : '';
		$req_url = "http://$host/post/index.xml?limit=100$login&tags=".uri_escape $query;
	}
	$req_url =~ s/(password_hash=)[^&]*/$1(hidden)/;
	$posts = $ua->get_posts($req_url) if $query;
	failed "$tag: $req_url\n$posts\n" unless ref $posts eq 'ARRAY';
	if (!@$posts) {
		$last_max = undef;
		print "No more posts, we're done!\n";
		last;
	}
	for (@$posts) {
		process() or $err++;
		my $next_max = $max > 0 ? $max * 2 / 5 : 500;
		if (time - $start_time > 60*5 and not $nolock) {
			put_last("max", $next_max);
			failed "$tag: Update taking over 5 minutes, aborting. Next time will try only $next_max\n";
		}
	}
	failed "$tag: Had errors.\n" if $err;
	failed "$tag: Had $warn warnings.\n" if $warn > $warnmax;

	print "Last change ID and post ID so far: $last_change - $last_post\n" unless $mode eq 'fromdb';
	update() if @add >= 500 or @insert >= 500;
}

$sth = undef;
print "Checking ", scalar keys %md5, " known MD5s...\n" if $mode eq 'fromdb';
for (keys %md5) {
	next unless $md5{$_};
	print "No post for $_! " and $warn++;
	/^(.)(.)(.)/;
	my $file = "$1/$2/$3/$_.jpg";
	print "But $file doesn't exist either!!\n" and next unless -f $file;
	push @tofetch, $_;
	print "Moving to todelete/. ";
	rename $file, "todelete/$_.jpg" or warn "$tag: Can't move: $!\n" and next;
	print "OK.\n";
}
goto AGAIN if @tofetch;

update();
failed "$tag: Had $warn warnings.\n" if $warn;
put_failed(0);
if (defined $last_max) {
	print "Still not all posts, trying $last_max more next time.\n";
	put_last("max", $last_max);
} else {
	unlink ".lastmax";
}

sub get_last {
	open my $last_f, "<", ".last$_[0]" or die "$tag: Can't read .last$_[0]: $!\n";
	$last_f = <$last_f>;
	die "$tag: Could not get last $_[0] ID.\n" unless defined $last_f;
	$last_f = 0 + $last_f;
	print "Last $_[0] ID: $last_f\n";
	return $last_f;
}
sub put_last {
	print "Writing last $_[0] = $_[1]\n";
	open my $out, ">", ".last$_[0]" or die "$tag: Can't write .last$_[0]: $!\n";
	print $out $_[1] or die "$tag: $!\n";
	close $out or die "$tag: $!\n";
}

sub get_failed {
	open my $failed_f, "<", ".failed" or warn "$tag: Can't read .failed: $!\n";
	my $failed = <$failed_f>;
	warn "$tag: Could not get last $_[0] ID.\n" unless defined $failed;
	$failed = 0 + $failed;
	print "Failed count: $failed\n";
	return $failed;
}
sub put_failed {
	print "Writing failed = $_[0]\n";
	open my $out, ">", ".failed" or die "$tag: Can't write .failed: $!\n";
	print $out $_[0] or die "$tag: $!\n";
	close $out or die "$tag: $!\n";
	unlink ".curmode";
}

sub process {
	my $quiet = $max > 200;

	$cnt++;
	failed "$tag: Invalid row (not a hashref): $_\n" unless ref $_ eq 'HASH';
	failed "$tag: Invalid row (no ID): @{[%$_]}\n" unless $_->{id};

	my $id = $_->{id};
	failed "$tag: Invalid ID $id: @{[%$_]}\n" unless $id eq 0 + $id;
	$id = 0 + $id;

	my $change = $_->{change};
	if (defined $change) {
		warn "$tag: Invalid change ID $change: @{[%$_]}\n" and $warn++ unless $change eq 0 + $change;
		$last_change=0+$change if $change > $last_change;
	}
	$last_post=0+$id if $id > $last_post;
	$last_del=0+$id if $id > $last_del;

	$_->{preview_url} ||= "deleted.jpg" if $_->{status} eq "disabled";
	failed "$tag: Invalid row (no URL): @{[%$_]}\n" unless $_->{preview_url};
	my $url = $_->{preview_url};

	my $md5 = lc $_->{md5};
	failed "$tag: Invalid md5: $md5\n" unless length $md5 =~ /^[0-9a-f]{32}$/;

	my ($file,$suf) = ($md5, substr $url, rindex $url, ".");
	$suf = ".jpg" unless $suf =~ /^\.[a-z]+$/;
	$suf = ".jpg" if $suf eq '.jpeg';
	$file =~ /^(.)(.)(.)/;
	$file = "$1/$2/$3/$file.jpg";
	print "$id: $url -> $file:" unless $quiet;
	print "\r$id \x1b[K" if $quiet;

	if ($_->{status} eq 'deleted' or $_->{status} eq 'disabled') {
		print "DELETED" unless $quiet;
		push @remove, sprintf "0x%x", $id if $mode ne 'fromdb' or $ids_db{$id} or $ids_online{$id};
		$deleted{$id} = 1;
		if (-e $file) {
			print " moving to deleted/";
			rename $file, "deleted/$md5.jpg" or die "\n$tag: Can't move $file to deleted/: $!\n";
		}
		$file = "";

	} elsif ($url =~ m#/(default|download|deleted|download-preview)\.png$#) {
		print "SKIPPED" unless $quiet;
		$file = "";

	} elsif (-e $file) {
		print "Exists" unless $quiet;

	} elsif ($suf ne '.jpg') {
		print STDERR "$tag: $id: $url -> $file: " and $quiet = 0 if $quiet;
		die "$tag: Suffix `$suf' not .jpg!\n";

	} else {
		print "$url -> $file:" and $quiet = 0 if $quiet;
		retrieve($url, $md5, $file) or $file = undef;
	}

	if ($mode eq 'fromdb') {
		if (not exists $md5{$md5}) {
			print "No file for $md5!\n" if $file and not -e $file;
			$md5{$md5} = 0;
		} elsif ($md5{$md5}) {
			$md5{$md5} = 0;
		} else {
			warn "$tag: Duplicate MD5 in posts table: $md5!\n" and $warn++;
		}
	}

	$_->{rating} = $def_rating if $def_rating and not defined $_->{rating};
	my $rating = $ratings{$_->{rating}};
	die "$tag: $id: Unknown rating `$_->{rating}'\n" unless $rating;

	push @insert,[$id,$_->{rating},$md5,Compress::Zlib::compress($_->{raw}, 9)] unless $_->{noinsert};
	my $rows = $sth_chk->execute($id);
	if ($rows == 1) {
		my @row = $sth_chk->fetchrow_array or exit 1;
		$row[0] ||= "";
		if ($file and $_->{rating} ne $row[0]) {
			print "\n$id: rating $row[0] -> $_->{rating} = $rating";
			push @update, [$id, sprintf "0x%x 1 $rating", $id];
		}
		$file = "";
	} elsif ($rows != 0) {
		die "$tag: Invalid row count for $id: $rows\n";
	}
	if ($file) {
		push @add, [$id, sprintf "0x%x 1 $rating:$ENV{HOME}/doujin/$tag/$file", $id];
	}
	print " OK\n" unless $quiet;
	return defined $file;
}

sub retrieve {
	my ($url, $md5, $file) = @_;
	my $tmpfile = "new/$md5.jpg";

	unlink $tmpfile;
	my $res = $ua->mirror($url, $tmpfile);
	if ($res->code == 500) {
		print "Failed (".$res->status_line.")! Trying again. ";
		$res = $ua->mirror($url, $tmpfile);
	}
	if ($res->code == 403) {
		print "Skipped (403)\n";
		print STDERR "$tag: $url: ".$res->status_line."\n";
		$warn++;
		return 1;
	}
	#if ($res->code == 404) {
	#	print "Skipped (404)\n";
	#	print STDERR "$tag: $url: ".$res->status_line."\n";
	#	#$warn++;
	#	return 1;
	#}
	if ($res->code >= 500) {
		print "Failed (".$res->status_line.")! Aborting.\n";
		failed "$tag: $url: ".$res->status_line."\n";
	}
	if (!is_success $res and $res->code != 304) {
		print "FAILED\n";
		print STDERR "$tag: $url: ".$res->status_line."\n";
		return;
	}

	open my $f, "<", $tmpfile or die "$tag: Can't read $tmpfile: $!\n";
	sysread $f, my $fhdr, 10 or die "$tag: Can't read $tmpfile: $!\n";
	use bytes;
	my $jpeghdr = "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46";
	if ($fhdr ne $jpeghdr) {
		sysread $f, $fhdr, 128*1024, -1 or die "$tag: Can't read $tmpfile: $!\n";
		if (-1 == index $fhdr, "No such file or directory: ") {
			$fhdr = join " ", map { sprintf "%02x", ord $_ } split //, $fhdr, length $jpeghdr;
			$jpeghdr = join " ", map { sprintf "%02x", ord $_ } split //, $jpeghdr;
			failed "$tag: No JPEG header:\nGot= $fhdr\nWant=$jpeghdr\n";
		}
		print "Failed (No such file or directory)\n";
		print STDERR "$tag: $url: No such file or directory\n";
		$warn++;
		unlink $tmpfile;
		return 1;
	}
	print -s $tmpfile;
	rename $tmpfile, $file or die "$tag: Can't move $tmpfile to $file: $!\n";
	#print -s $file; -- not always present right away on NFS
	return 1;
}

sub update {
	my @toadd = @add;
	my @toremove = @remove;
	my @toupdate = @update;
	if (@add or @remove or @update) {
		if (!update_iqdb()) {
			print "iqdb update failed, trying again after 10 seconds\n";
			@add = @toadd;
			@remove = @toremove;
			@update = @toupdate;
			sleep 10;
			if (!update_iqdb()) {
				failed "$tag: iqdb update failed";
			}
		}
	}
	update_db() if @insert;
	print "Last committed change/post: $last_change $last_post\n";
	
	if ($mode eq 'full') {
		put_last("change", $last_change);
	} elsif ($mode eq 'update') {
		put_last("id", $last_post);
	}
}

sub update_iqdb {
	print "Updating DB: removing ", scalar @remove, " images, adding ", scalar @add, " and updating ", scalar @update, " images.\n";

	$SIG{PIPE} = 'IGNORE';
	$|=1;
	open my $olderr, ">&STDERR" or die "Can't dup STDERR: $!\n";
	open STDERR, ">&STDOUT" or die "Can't redirect STDERR to STDOUT: $!\n";
	open my $iqdb, "|$ENV{HOME}/bin/iqdb command $db_file 2>&1|tee -a /dev/fd/2|egrep -v -q ^3 2>&1" or die "$tag: Can't run iqdb: $!\n";
	open STDERR, ">&", $olderr or die "Can't restore STDERR: $!\n";
	select $iqdb; $|=1; select STDOUT;
	system "sync";

	while (@add or @remove or @update) {
		print "Opening connection for ", @add+@remove+@update, " commands...\n";
		my $nc;
		unless ($no_online) {
			open $nc, "| nc s2.iqdb.hanyuu.net 5588 2>&1|tee -a /dev/fd/2|egrep -v -q ^3 2>&1" or die "$tag: Can't start nc: $!\n";
			select $nc; $|=1; select STDOUT;
		}

		# Only add 16 images per connection, to let other clients query it too in-between.
		my $added = 0;
		while ($added < 16 and (@add or @remove or @update)) {
			my $cmd;
			if (@remove) {
				$cmd = shift @remove;
				print "remove X $cmd\n";
				print $nc "remove $dbid $cmd\n" unless $no_online;
				print $iqdb "remove 0 $cmd\n";
			} elsif (@add) {
				$cmd = shift @add;
				if ($deleted{$cmd->[0]}) {
					print "NOT ADDING, REMOVED LATER: @$cmd\n";
					$warn++;
					next;
				}
				$cmd = $cmd->[1];
				print "add X $cmd\n";
				print $nc "add $dbid $cmd\n" unless $no_online;
				print $iqdb "add 0 $cmd\n";
				$added++;
			} else {
				$cmd = shift @update;
				if ($deleted{$cmd->[0]}) {
					print "NOT UPDATING, REMOVED LATER: @$cmd\n";
					$warn++;
					next;
				}
				$cmd = $cmd->[1];
				print "set_res X $cmd\n";
				print $nc "set_res $dbid $cmd\n" unless $no_online;
				print $iqdb "set_res 0 $cmd\n";
			}
		}
		unless ($no_online) {
			print $nc "done now\n";
			close $nc;
			print $iqdb "done now\n" and return 0 if $?; #die "$tag: Online failed!\n" if $?;
		}
	}
	print $iqdb "quit now\n";
	close $iqdb or return 0; # die "$tag: File failed!\n";
	return 1;
}

sub update_db {
	print "Updating DB, ", scalar @insert, " statements... ";
	$sth_ins->execute(@$_) or die "$tag: insert failed\n" for @insert;
	@insert = ();
	print "OK.\n";
}

sub get_ids {
	print "Retrieving DB ids... ";
	open my $iqdb, "-|", "$ENV{HOME}/bin/iqdb", "list", $db_file or die "$tag: Can't run iqdb: $!\n";
	while (<$iqdb>) {
		chomp;
		$ids_db{hex $_} = 1;
	}
	print scalar keys %ids_db, " ids.\n";
	return if $no_online;

	print "Retrieving online ids... ";
	open my $nc, "-|", "echo -e 'list $dbid\\ndone now\\n'|nc localhost 5566" or die "$tag: Can't start nc: $!\n";
	while (<$nc>) {
		chomp;
		/^000 / and next;
		/^100 ([0-9a-f]+)$/ or print "Unknown response: $_\n" and next;
		$ids_online{hex $1} = 1;
	}
	print scalar keys %ids_online, " ids.\n";
}

package MyUserAgent;
use base qw(LWP::UserAgent XML::Simple);
use Encode::Encoding qw(decode);
sub prepare_request {
	my $self = shift;
	my $req = $self->SUPER::prepare_request(shift);
	$req->header(Referer => "http://$host/");
	return $req;
}
sub get_posts {
	my ($self,$url) = @_;
	$self->default_header("Accept-Encoding" => "gzip, deflate");
	my $res = $self->get($url);
	$self->default_headers->remove_header("Accept-Encoding");
	my $try = 0;
	while ($res->status_line eq '500 read timeout') {
		$try++;
		last if $try > 2;
		sleep (2 << $try);
		print STDERR "$tag: ", $res->status_line, ", trying again.\n";
		$res = $self->get($url);
	}
	::failed "$tag: Could not get xml response: ".$res->status_line.".\nURL was: $url\n" unless $res->is_success;
	open my $xml, ">", "/usr/src/packages/sim/last.zxml" or die "$tag: Can't write last.zxml: $!\n"; print $xml $res->content; close $xml;

	my $decoded = $res->decoded_content();
	::failed "$tag: Could not decode content: $@\nURL was: $url\nUndecoded length is ".length $res->content,"\n" unless $decoded;

	my $err = "No XML header: ".substr($decoded, 0, 40);
	while ($decoded =~ s/^\s*<\?xml[^>]*>\s*<([a-z]+)[^>]*>\s*//i) {
		$err = "Root tag is '$1' not 'posts' or 'images'\n" and last unless $1 eq 'posts' or $1 eq 'images';

		return parse(split /(?<=\>)\s+/, $decoded);
	}

	if ($decoded =~ /^<html>.*maintenance/i) {
		print STDERR "$tag: maintenance\n";
		return [];
	}

	open my $dump, ">", "/usr/src/packages/sim/last.xml";
	print $dump $decoded;
	close $dump;
	::failed "$tag: XML parsing failed: $err\n";
}

sub parse {
	my @posts;
	for (@_) {
		last if m#^\s*</[a-z]#;
		next if /^\s*$/;
		my $post = eval { XML::Simple::XMLin($_) };
		$post = eval { print STDERR "XML decode failed, trying to fix UTF-8. "; $_ = Encode::decode("utf8", $_, Encode::FB_XMLCREF); XML::Simple::XMLin($_) } if $@;
		return "$_: $@" if $@;
		$post->{raw} = $_;
		push @posts, $post;
	}
	return \@posts;
}
