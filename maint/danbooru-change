#!/usr/bin/perl

use warnings;
use strict;

use DBI;
use URI::Escape;
use File::Find;
use Compress::Zlib;

die "No lockfile!\n" unless -e "update.lock";

#system("renice 15 $$");
my $tag = shift or die "Give server tag on command line.\n";
my $no_online = shift, 1 if @ARGV and $ARGV[0] eq '-r';
my $mode = "update";
$mode = shift if @ARGV and ($ARGV[0] =~ /^[a-z]+$/);
my $max = 0+(shift||0);
my $cnt = 0;
print "Getting no more than $max posts.\n" if $max > 0;

our ($user,$pw,$host,$table,$dbid,$db_file);
do "/usr/src/packages/sim/$tag.cfg" and $user and $pw and $host and $table and $dbid and $db_file or die "Can't get DB settings: $!\n";
$db_file="/opt/stuff/$db_file";
die "$db_file does not exist\n" unless -e $db_file;
chdir "$ENV{HOME}/doujin/$tag" or die "Can't chdir: $!\n";

print "Site: $tag Mode: $mode\n";

my $last_change = get_last('change');
my $last_post = get_last('id');

my $pwfile = "$ENV{HOME}/.dou-pw-admin";
open my $f, "<", $pwfile or die "Can't read $pwfile: $!\n";
my $password = <$f>;
chomp $password;
die "No password in $pwfile\n" unless $password;

my %ids_db;
my %ids_online;
my %md5;

if ($mode eq 'fromdb') {
	print "Finding images... ";
	find({ wanted => sub { return unless -f and m#^([0-9a-f]{32})\.#; $md5{$1} = 1; } }, "0".."9", "a".."f");
	print scalar keys %md5, " found.\n";
	get_ids();
}

my $dbh = DBI->connect("DBI:mysql:database=sim:host=localhost", "simadmin", $password)
	or die "Can't connect to database: $DBI::errstr\n";

$dbh->do(<<EOT) or die "FAILED.\n";
	create table if not exists $table (
		id int not null,
		rating char(1) character set latin1,
		md5 binary(32) not null,
		post blob not null,

		UNIQUE INDEX(id),
		PRIMARY KEY(id),
		UNIQUE INDEX(md5)
	) CHARSET=utf8;
EOT

my $ua = MyUserAgent->new;
$ua->timeout(10);
$ua->env_proxy;
$ua->default_header("Accept-Encoding" => "gzip, deflate");
$ua->agent("iqdb/0.1 (+http://iqdb.yi.org/)");

my @remove;
my @add;
my @insert;
my @update;

my @tofetch;

my %deleted;

my $sth_chk = $dbh->prepare("select rating from $table where id=?") or exit 1;
my $sth_ins = $dbh->prepare("insert into $table (id, rating, md5, post) values (?, ?, ?, ?) on duplicate key update id=values(id),rating=values(rating),post=values(post)") or exit 1;

my %ratings = (a => 0x02, e => 0x04, q => 0x08, s => 0x10);

my $warn = 0;
my $err = 0;
my $last_del = 0;

my $sth;
if ($mode eq 'fromdb') {
	$sth = $dbh->prepare("select * from $table") or exit 1;
	$sth->execute();
}

AGAIN:
while(!$max or $cnt < $max) {
	my $query;
	my $posts;
	if ($mode eq 'full') {
		$query = "change:>$last_change order:change";
	} elsif ($mode eq 'deleted') {
		$query = "id:>$last_del order:id deleted:true";
	} elsif ($mode eq 'update') {
		$query = "id:>$last_post order:id";
	} elsif ($mode eq 'fromdb') {
		if (@tofetch) {
			my $md5 = shift @tofetch;
			print "Trying to get MD5 $md5...\n";
			$query = "md5:$md5";
		} else {
			last unless $sth;
			my $row = $sth->fetchrow_hashref or last;
			$posts = MyUserAgent::parse(Compress::Zlib::uncompress($row->{post}));
			$_->{noinsert} = 1 for @$posts;
		}
	} else {
		die "Unknown mode: $mode\n";
	}
	$posts = $ua->get_posts("http://$host/post/index.xml?limit=100&login=$user&password_hash=$pw&tags=".uri_escape $query) if $query;
	last unless @$posts;
	for (@$posts) {
		process() or $err++;
	}
	die "Had errors.\n" if $err;
	die "Had $warn warnings.\n" if $warn > 4;

	print "Last change ID and post ID so far: $last_change - $last_post\n" unless $mode eq 'fromdb';
	update() if @add >= 500 or @insert >= 500;
}

$sth = undef;
print "Checking ", scalar keys %md5, " known MD5s...\n" if $mode eq 'fromdb';
for (keys %md5) {
	next unless $md5{$_};
	print "No post for $_! " and $warn++;
	/^(.)(.)(.)/;
	my $file = "$1/$2/$3/$_.jpg";
	print "But $file doesn't exist either!!\n" and next unless -f $file;
	push @tofetch, $_;
	print "Moving to todelete/. ";
	rename $file, "todelete/$_.jpg" or warn "Can't move: $!\n" and next;
	print "OK.\n";
}
goto AGAIN if @tofetch;

update();
die "Had $warn warnings.\n" if $warn;

sub get_last {
	open my $last_f, "<", ".last$_[0]" or die "Can't read .last$_[0]: $!\n";
	$last_f = <$last_f>;
	die "Could not get last $_[0] ID.\n" unless defined $last_f;
	$last_f = 0 + $last_f;
	print "Last $_[0] ID: $last_f\n";
	return $last_f;
}
sub put_last {
	print "Writing last $_[0] = $_[1]\n";
	open my $out, ">", ".last$_[0]" or die "Can't write .last$_[0]: $!\n";
	print $out $_[1] or die $!;
	close $out or die $!;
}

sub process {
	$cnt++;
	die "Invalid row (no ID): $_\n" unless $_->{id};

	my $id = $_->{id};
	die "Invalid ID $id: $_\n" unless $id eq 0 + $id;
	$id = 0 + $id;

	my $change = $_->{change};
	warn "Invalid change ID $change: @{[%$_]}\n" and $warn++ unless $change eq 0 + $change;
	$last_change=0+$change if $change > $last_change;
	$last_post=0+$id if $id > $last_post;
	$last_del=0+$id if $id > $last_del;

	die "Invalid row (no URL): $_\n" unless $_->{preview_url};
	my $url = $_->{preview_url};

	my $md5 = lc $_->{md5};
	die "Invalid md5: $md5\n" unless length $md5 =~ /^[0-9a-f]{32}$/;

	my ($file,$suf) = ($md5, substr $url, rindex $url, ".");
	$file =~ /^(.)(.)(.)/;
	$file = "$1/$2/$3/$file.jpg";
	print "$id: $url -> $file:" unless $max;

	if ($_->{status} eq 'deleted') {
		print "DELETED" unless $max;
		push @remove, sprintf "0x%x", $id if $mode ne 'fromdb' or $ids_db{$id} or $ids_online{$id};
		$deleted{$id} = 1;
		if (-e $file) {
			print " moving to deleted/";
			rename $file, "deleted/$md5.jpg" or die "\nCan't move $file to deleted/: $!\n";
		}
		$file = "";

	} elsif ($url =~ m#/(default|download|deleted)\.png$#) {
		print "SKIPPED" unless $max;
		$file = "";

	} elsif (-e $file) {
		print "Exists" unless $max;

	} elsif ($suf ne '.jpg') {
		print STDERR "$id: $url -> $file: " if $max;
		die "Suffix not .jpg!\n";

	} else {
		print "$id: $url -> $file:" if $max;
		retrieve($url, $md5, $file) or $file = undef;
	}

	if ($mode eq 'fromdb') {
		if (not exists $md5{$md5}) {
			print "No file for $md5!\n" if $file and not -e $file;
			$md5{$md5} = 0;
		} elsif ($md5{$md5}) {
			$md5{$md5} = 0;
		} else {
			warn "Duplicate MD5 in posts table: $md5!\n" and $warn++;
		}
	}

	my $rating = $ratings{$_->{rating}};
	die "$id: Unknown rating `$_->{rating}'\n" unless $rating;

	push @insert,[$id,$_->{rating},$md5,Compress::Zlib::compress($_->{raw}, 9)] unless $_->{noinsert};
	my $rows = $sth_chk->execute($id);
	if ($rows == 1) {
		my @row = $sth_chk->fetchrow_array or exit 1;
		$row[0] ||= "";
		if ($file and $_->{rating} ne $row[0]) {
			print "\n$id: rating $row[0] -> $_->{rating} = $rating";
			push @update, [$id, sprintf "0x%x 1 $rating", $id];
		}
		$file = "";
	} elsif ($rows != 0) {
		die "Invalid row count: $rows\n";
	}
	if ($file) {
		push @add, [$id, sprintf "0x%x 1 $rating:$ENV{HOME}/doujin/$tag/$file", $id];
	}
	print " OK\n";
	return defined $file;
}

sub retrieve {
	my ($url, $md5, $file) = @_;
	my $tmpfile = "new/$md5.jpg";

	my $res = $ua->mirror($url, $tmpfile);
	if ($res->code == 500) {
		print "Failed (".$res->status_line.")! Trying again. ";
		$res = $ua->mirror($url, $tmpfile);
	}
	if ($res->code == 403) {
		print "Skipped (403)\n";
		print STDERR "$url: ".$res->status_line."\n";
		$warn++;
		return 1;
	}
	#if ($res->code == 404) {
	#	print "Skipped (404)\n";
	#	print STDERR "$url ($id): ".$res->status_line."\n";
	#	$warn++;
	#	next;
	#}
	if ($res->code >= 500) {
		print "Failed (".$res->status_line.")! Aborting.\n";
		die "$url: ".$res->status_line."\n";
	}
	if (!is_success $res and $res->code != 304) {
		print "FAILED\n";
		print STDERR "$url: ".$res->status_line."\n";
		return;
	}

	open my $f, "<", $tmpfile or die "Can't read $tmpfile: $!\n";
	sysread $f, my $fhdr, 10 or die "Can't read $tmpfile: $!\n";
	use bytes;
	my $jpeghdr = "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46";
	$fhdr eq $jpeghdr or die "No JPEG header:\nGot= $fhdr\nWant=$jpeghdr\n";
	rename $tmpfile, $file or die "Can't move $tmpfile to $file: $!\n";
	print -s $file;
	return 1;
}

sub update {
	update_iqdb() if @add or @remove or @update;
	update_db() if @insert;
	print "Last committed change/post: $last_change $last_post\n";
	
	if ($mode eq 'full') {
		put_last("change", $last_change);
	} elsif ($mode eq 'update') {
		put_last("id", $last_post);
	}
}

sub update_iqdb {
	print "Updating DB: removing ", scalar @remove, " images, adding ", scalar @add, " and updating ", scalar @update, " images.\n";

	$SIG{PIPE} = 'IGNORE';
	$|=1;
	open my $iqdb, "|-", "$ENV{HOME}/bin/iqdb", "command", $db_file or die "Can't run iqdb: $!\n";
	select $iqdb; $|=1; select STDOUT;

	while (@add or @remove or @update) {
		print "Opening connection for ", @add+@remove+@update, " commands...\n";
		my $nc;
		unless ($no_online) {
			open $nc, "|-", "nc", "localhost", "5566" or die "Can't start nc: $!\n";
			select $nc; $|=1; select STDOUT;
		}

		# Only add 16 images per connection, to let other clients query it too in-between.
		my $added = 0;
		while ($added < 16 and (@add or @remove or @update)) {
			my $cmd;
			if (@remove) {
				$cmd = shift @remove;
				print "remove X $cmd\n";
				print $nc "remove $dbid $cmd\n" unless $no_online;
				print $iqdb "remove 0 $cmd\n";
			} elsif (@add) {
				$cmd = shift @add;
				if ($deleted{$cmd->[0]}) {
					print "NOT ADDING, REMOVED LATER: @$cmd\n";
					$warn++;
					next;
				}
				$cmd = $cmd->[1];
				print "add X $cmd\n";
				print $nc "add $dbid $cmd\n" unless $no_online;
				print $iqdb "add 0 $cmd\n";
				$added++;
			} else {
				$cmd = shift @update;
				if ($deleted{$cmd->[0]}) {
					print "NOT UPDATING, REMOVED LATER: @$cmd\n";
					$warn++;
					next;
				}
				$cmd = $cmd->[1];
				print "set_res X $cmd\n";
				print $nc "set_res $dbid $cmd\n" unless $no_online;
				print $iqdb "set_res 0 $cmd\n";
			}
		}
		unless ($no_online) {
			print $nc "done now\n";
			close $nc;
			print $iqdb "done now\n" and die "Online failed!\n" if $?;
		}
	}
	print $iqdb "quit now\n";
	close $iqdb or die "File failed!\n";
}

sub update_db {
	print "Updating DB, ", scalar @insert, " statements... ";
	$sth_ins->execute(@$_) or die for @insert;
	@insert = ();
	print "OK.\n";
}

sub get_ids {
	print "Retrieving DB ids... ";
	open my $iqdb, "-|", "$ENV{HOME}/bin/iqdb", "list", $db_file or die "Can't run iqdb: $!\n";
	while (<$iqdb>) {
		chomp;
		$ids_db{hex $_} = 1;
	}
	print scalar keys %ids_db, " ids.\n";
	return if $no_online;

	print "Retrieving online ids... ";
	open my $nc, "-|", "echo -e 'list $dbid\\ndone now\\n'|nc localhost 5566" or die "Can't start nc: $!\n";
	while (<$nc>) {
		chomp;
		/^000 / and next;
		/^100 ([0-9a-f]+)$/ or print "Unknown response: $_\n" and next;
		$ids_online{hex $1} = 1;
	}
	print scalar keys %ids_online, " ids.\n";
}

package MyUserAgent;
use base qw(LWP::UserAgent XML::Simple);
sub prepare_request {
	my $self = shift;
	my $req = $self->SUPER::prepare_request(shift);
	$req->header(Referer => "http://$host/");
	return $req;
}
sub get_posts {
	my ($self,$url) = @_;
	my $res = $self->get($url);
	my $try = 0;
	while ($res->status_line eq '500 read timeout') {
		$try++;
		last if $try > 2;
		sleep (2 << $try);
		print STDERR $res->status_line, ", trying again.\n";
		$res = $self->get($url);
	}
	die "Could not get xml response: ".$res->status_line.".\nURL was: $url\n" unless $res->is_success;
	open my $xml, ">", "/usr/src/packages/sim/last.zxml" or die; print $xml $res->content; close $xml;

	my $decoded = $res->decoded_content();
	die "Could not decode content: $@\nURL was: $url\nUndecoded length is ".length $res->content,"\n" unless $decoded;

	my $line;
	while (1) {
		my @lines = split /\n+/, $decoded;
		$line = shift @lines; $line = "No XML header: $line" and last unless $line =~ /^<\?xml/;
		$line = shift @lines; $line = "No posts root tag: $line" and last unless $line =~ /^<posts/;
		return parse(@lines);
	}

	open my $dump, ">", "/usr/src/packages/sim/last.xml";
	print $dump $decoded;
	close $dump;
	die "XML parsing failed: $line\n";
}

sub parse {
	my @posts;
	for (@_) {
		next if /^\s*$/ or m#^\s*</posts#;
		my $post = eval { XML::Simple::XMLin($_) };
		return "$_: $@" if $@;
		$post->{raw} = $_;
		push @posts, $post;
	}
	return \@posts;
}
